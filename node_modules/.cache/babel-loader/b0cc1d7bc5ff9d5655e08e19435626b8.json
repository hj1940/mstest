{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Search = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _getNestedFieldValue = require('./getNestedFieldValue');\n\nvar _getNestedFieldValue2 = _interopRequireDefault(_getNestedFieldValue);\n\nvar _index = require('./IndexStrategy/index');\n\nvar _index2 = require('./Sanitizer/index');\n\nvar _index3 = require('./SearchIndex/index');\n\nvar _index4 = require('./Tokenizer/index');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\n\n\nvar Search = exports.Search = function () {\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n  function Search(uidFieldName) {\n    _classCallCheck(this, Search);\n\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName; // Set default/recommended strategies\n\n    this._indexStrategy = new _index.PrefixIndexStrategy();\n    this._searchIndex = new _index3.TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new _index2.LowerCaseSanitizer();\n    this._tokenizer = new _index4.SimpleTokenizer();\n    this._documents = [];\n    this._searchableFields = [];\n  }\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n\n  _createClass(Search, [{\n    key: 'addDocument',\n\n    /**\n     * Add a searchable document to the index. Document will automatically be indexed for search.\n     * @param document\n     */\n    value: function addDocument(document) {\n      this.addDocuments([document]);\n    }\n    /**\n     * Adds searchable documents to the index. Documents will automatically be indexed for search.\n     * @param document\n     */\n\n  }, {\n    key: 'addDocuments',\n    value: function addDocuments(documents) {\n      this._documents = this._documents.concat(documents);\n      this.indexDocuments_(documents, this._searchableFields);\n    }\n    /**\n     * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n     *\n     * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n     */\n\n  }, {\n    key: 'addIndex',\n    value: function addIndex(field) {\n      this._searchableFields.push(field);\n\n      this.indexDocuments_(this._documents, [field]);\n    }\n    /**\n     * Search all documents for ones matching the specified query text.\n     * @param query\n     * @returns {Array<Object>}\n     */\n\n  }, {\n    key: 'search',\n    value: function search(query) {\n      var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n      return this._searchIndex.search(tokens, this._documents);\n    }\n    /**\n     * @param documents\n     * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n     * @private\n     */\n\n  }, {\n    key: 'indexDocuments_',\n    value: function indexDocuments_(documents, _searchableFields) {\n      this._initialized = true;\n      var indexStrategy = this._indexStrategy;\n      var sanitizer = this._sanitizer;\n      var searchIndex = this._searchIndex;\n      var tokenizer = this._tokenizer;\n      var uidFieldName = this._uidFieldName;\n\n      for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n        var doc = documents[di];\n        var uid;\n\n        if (uidFieldName instanceof Array) {\n          uid = (0, _getNestedFieldValue2.default)(doc, uidFieldName);\n        } else {\n          uid = doc[uidFieldName];\n        }\n\n        for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n          var fieldValue;\n          var searchableField = _searchableFields[sfi];\n\n          if (searchableField instanceof Array) {\n            fieldValue = (0, _getNestedFieldValue2.default)(doc, searchableField);\n          } else {\n            fieldValue = doc[searchableField];\n          }\n\n          if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n            fieldValue = fieldValue.toString();\n          }\n\n          if (typeof fieldValue === 'string') {\n            var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n            for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n              var fieldToken = fieldTokens[fti];\n              var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n              for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n                var expandedToken = expandedTokens[eti];\n                searchIndex.indexDocument(expandedToken, uid, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'indexStrategy',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: 'sanitizer',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n\n  }, {\n    key: 'searchIndex',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: 'tokenizer',\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n\n  return Search;\n}();","map":{"version":3,"sources":["../../source/Search.js"],"names":["Search","Error","value","document","documents","field","query","tokens","_searchableFields","indexStrategy","sanitizer","searchIndex","tokenizer","uidFieldName","di","numDocuments","doc","uid","sfi","numSearchableFields","searchableField","fieldValue","fieldTokens","fti","numFieldValues","fieldToken","expandedTokens","eti","nummExpandedTokens","expandedToken"],"mappings":"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","sourcesContent":["// @flow\nimport getNestedFieldValue from './getNestedFieldValue';\n\nimport { PrefixIndexStrategy } from './IndexStrategy/index';\nimport { LowerCaseSanitizer } from './Sanitizer/index';\nimport { TfIdfSearchIndex } from './SearchIndex/index';\nimport { SimpleTokenizer } from './Tokenizer/index';\n\nimport type { IIndexStrategy } from './IndexStrategy/index';\nimport type { ISanitizer } from './Sanitizer/index';\nimport type { ISearchIndex } from './SearchIndex/index';\nimport type { ITokenizer } from './Tokenizer/index';\n\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\nexport class Search {\n\n  _documents : Array<Object>;\n  _indexStrategy : IIndexStrategy;\n  _initialized : boolean;\n  _sanitizer : ISanitizer;\n\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n  _searchableFields : Array<string|Array<string>>;\n\n  _searchIndex : ISearchIndex;\n  _tokenizer : ITokenizer;\n  _uidFieldName : string | Array<string>;\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  constructor(uidFieldName : string | Array<string>) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName;\n\n    // Set default/recommended strategies\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n\n    this._documents = [];\n    this._searchableFields = [];\n  }\n\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set indexStrategy(value : IIndexStrategy) {\n    if (this._initialized) {\n      throw Error('IIndexStrategy cannot be set after initialization');\n    }\n\n    this._indexStrategy = value;\n  }\n\n  get indexStrategy() : IIndexStrategy {\n    return this._indexStrategy;\n  }\n\n  /**\n   * Override the default text sanitizing strategy.\n   * @param value Custom text sanitizing strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set sanitizer(value : ISanitizer) {\n    if (this._initialized) {\n      throw Error('ISanitizer cannot be set after initialization');\n    }\n\n    this._sanitizer = value;\n  }\n  get sanitizer() : ISanitizer {\n    return this._sanitizer;\n  }\n\n  /**\n   * Override the default search index strategy.\n   * @param value Custom search index strategy\n   * @throws Error if documents have already been indexed\n   */\n  set searchIndex(value : ISearchIndex) {\n    if (this._initialized) {\n      throw Error('ISearchIndex cannot be set after initialization');\n    }\n\n    this._searchIndex = value;\n  }\n  get searchIndex() : ISearchIndex {\n    return this._searchIndex;\n  }\n\n  /**\n   * Override the default text tokenizing strategy.\n   * @param value Custom text tokenizing strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n  set tokenizer(value : ITokenizer) {\n    if (this._initialized) {\n      throw Error('ITokenizer cannot be set after initialization');\n    }\n\n    this._tokenizer = value;\n  }\n  get tokenizer() : ITokenizer {\n    return this._tokenizer;\n  }\n\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n  addDocument(document : Object) : void {\n    this.addDocuments([document]);\n  }\n\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */\n  addDocuments(documents : Array<Object>) : void {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */\n  addIndex(field : string|Array<string>) {\n    this._searchableFields.push(field);\n    this.indexDocuments_(this._documents, [field]);\n  }\n\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */\n  search(query : string) : Array<Object> {\n    var tokens : Array<string> = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n    return this._searchIndex.search(tokens, this._documents);\n  }\n\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */\n  indexDocuments_(documents : Array<Object>, _searchableFields : Array<string|Array<string>>) : void {\n    this._initialized = true;\n\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue;\n        var searchableField = _searchableFields[sfi];\n\n        if (searchableField instanceof Array) {\n          fieldValue = getNestedFieldValue(doc, searchableField);\n        } else {\n          fieldValue = doc[searchableField];\n        }\n\n        if (\n          fieldValue != null &&\n          typeof fieldValue !== 'string' &&\n          fieldValue.toString\n        ) {\n          fieldValue = fieldValue.toString();\n        }\n\n        if (typeof fieldValue === 'string') {\n          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n            var fieldToken = fieldTokens[fti];\n            var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n              var expandedToken = expandedTokens[eti];\n\n              searchIndex.indexDocument(expandedToken, uid, doc);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}