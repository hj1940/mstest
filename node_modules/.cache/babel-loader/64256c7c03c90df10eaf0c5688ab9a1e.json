{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TfIdfSearchIndex = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _getNestedFieldValue = require('../getNestedFieldValue');\n\nvar _getNestedFieldValue2 = _interopRequireDefault(_getNestedFieldValue);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\n\n\nvar TfIdfSearchIndex = exports.TfIdfSearchIndex = function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    _classCallCheck(this, TfIdfSearchIndex);\n\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(TfIdfSearchIndex, [{\n    key: 'indexDocument',\n    value: function indexDocument(token, uid, doc) {\n      this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n      var tokenMap = this._tokenMap;\n      var tokenDatum;\n\n      if (_typeof(tokenMap[token]) !== 'object') {\n        tokenMap[token] = tokenDatum = {\n          $numDocumentOccurrences: 0,\n          $totalNumOccurrences: 1,\n          $uidMap: {}\n        };\n      } else {\n        tokenDatum = tokenMap[token];\n        tokenDatum.$totalNumOccurrences++;\n      }\n\n      var uidMap = tokenDatum.$uidMap;\n\n      if (_typeof(uidMap[uid]) !== 'object') {\n        tokenDatum.$numDocumentOccurrences++;\n        uidMap[uid] = {\n          $document: doc,\n          $numTokenOccurrences: 1\n        };\n      } else {\n        uidMap[uid].$numTokenOccurrences++;\n      }\n    }\n    /**\n     * @inheritDocs\n     */\n\n  }, {\n    key: 'search',\n    value: function search(tokens, corpus) {\n      var uidToDocumentMap = {};\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = tokens[i];\n        var tokenMetadata = this._tokenMap[token]; // Short circuit if no matches were found for any given token.\n\n        if (!tokenMetadata) {\n          return [];\n        }\n\n        if (i === 0) {\n          var keys = Object.keys(tokenMetadata.$uidMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n            uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n          }\n        } else {\n          var keys = Object.keys(uidToDocumentMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            if (_typeof(tokenMetadata.$uidMap[uid]) !== 'object') {\n              delete uidToDocumentMap[uid];\n            }\n          }\n        }\n      }\n\n      var documents = [];\n\n      for (var uid in uidToDocumentMap) {\n        documents.push(uidToDocumentMap[uid]);\n      }\n\n      var calculateTfIdf = this._createCalculateTfIdf(); // Return documents sorted by TF-IDF\n\n\n      return documents.sort(function (documentA, documentB) {\n        return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n      });\n    }\n  }, {\n    key: '_createCalculateIdf',\n    value: function _createCalculateIdf() {\n      var tokenMap = this._tokenMap;\n      var tokenToIdfCache = this._tokenToIdfCache;\n      return function calculateIdf(token, documents) {\n        if (!tokenToIdfCache[token]) {\n          var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n          tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n        }\n\n        return tokenToIdfCache[token];\n      };\n    }\n  }, {\n    key: '_createCalculateTfIdf',\n    value: function _createCalculateTfIdf() {\n      var tokenMap = this._tokenMap;\n      var uidFieldName = this._uidFieldName;\n\n      var calculateIdf = this._createCalculateIdf();\n\n      return function calculateTfIdf(tokens, document, documents) {\n        var score = 0;\n\n        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n          var token = tokens[i];\n          var inverseDocumentFrequency = calculateIdf(token, documents);\n\n          if (inverseDocumentFrequency === Infinity) {\n            inverseDocumentFrequency = 0;\n          }\n\n          var uid;\n\n          if (uidFieldName instanceof Array) {\n            uid = document && (0, _getNestedFieldValue2.default)(document, uidFieldName);\n          } else {\n            uid = document && document[uidFieldName];\n          }\n\n          var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n          score += termFrequency * inverseDocumentFrequency;\n        }\n\n        return score;\n      };\n    }\n  }]);\n\n  return TfIdfSearchIndex;\n}();\n\n;","map":{"version":3,"sources":["../../../source/SearchIndex/TfIdfSearchIndex.js"],"names":["TfIdfSearchIndex","token","uid","doc","tokenMap","tokenDatum","$numDocumentOccurrences","$totalNumOccurrences","$uidMap","uidMap","$document","$numTokenOccurrences","tokens","corpus","uidToDocumentMap","i","numTokens","tokenMetadata","keys","Object","j","numKeys","documents","calculateTfIdf","tokenToIdfCache","numDocumentsWithToken","Math","uidFieldName","calculateIdf","score","inverseDocumentFrequency","document","termFrequency"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;;;;;;;;;;;;;;AAuBA;;;;;IAGaA,gB,WAAAA,gB;AAKX,WAAA,gBAAA,CAAA,YAAA,EAAmD;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;;AACjD,SAAA,aAAA,GAAA,YAAA;AACA,SAAA,gBAAA,GAAA,EAAA;AACA,SAAA,SAAA,GAAA,EAAA;AACD;AAED;;;;;;;kCAGcC,K,EAAgBC,G,EAAcC,G,EAAqB;AAC/D,WAAA,gBAAA,GAD+D,EAC/D,CAD+D,CACnC;;AAE5B,UAAIC,QAAAA,GAAW,KAAf,SAAA;AACA,UAAA,UAAA;;AAEA,UAAI,OAAA,CAAOA,QAAAA,CAAP,KAAOA,CAAP,CAAA,KAAJ,QAAA,EAAyC;AACvCA,QAAAA,QAAAA,CAAAA,KAAAA,CAAAA,GAAkBC,UAAAA,GAAa;AAC7BC,UAAAA,uBAAAA,EAD6B,CAAA;AAE7BC,UAAAA,oBAAAA,EAF6B,CAAA;AAG7BC,UAAAA,OAAAA,EAAS;AAHoB,SAA/BJ;AADF,OAAA,MAMO;AACLC,QAAAA,UAAAA,GAAaD,QAAAA,CAAbC,KAAaD,CAAbC;AACAA,QAAAA,UAAAA,CAAAA,oBAAAA;AACD;;AAED,UAAII,MAAAA,GAASJ,UAAAA,CAAb,OAAA;;AAEA,UAAI,OAAA,CAAOI,MAAAA,CAAP,GAAOA,CAAP,CAAA,KAAJ,QAAA,EAAqC;AACnCJ,QAAAA,UAAAA,CAAAA,uBAAAA;AACAI,QAAAA,MAAAA,CAAAA,GAAAA,CAAAA,GAAc;AACZC,UAAAA,SAAAA,EADY,GAAA;AAEZC,UAAAA,oBAAAA,EAAsB;AAFV,SAAdF;AAFF,OAAA,MAMO;AACLA,QAAAA,MAAAA,CAAAA,GAAAA,CAAAA,CAAAA,oBAAAA;AACD;AACF;AAED;;;;;;2BAGOG,M,EAAwBC,M,EAAwC;AACrE,UAAIC,gBAAAA,GAAJ,EAAA;;AAEA,WAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,SAAAA,GAAYJ,MAAAA,CAA5B,MAAA,EAA2CG,CAAAA,GAA3C,SAAA,EAA0DA,CAA1D,EAAA,EAA+D;AAC7D,YAAId,KAAAA,GAAQW,MAAAA,CAAZ,CAAYA,CAAZ;AACA,YAAIK,aAAAA,GAAgB,KAAA,SAAA,CAApB,KAAoB,CAApB,CAF6D,CAI7D;;AACA,YAAI,CAAJ,aAAA,EAAoB;AAClB,iBAAA,EAAA;AACD;;AAED,YAAIF,CAAAA,KAAJ,CAAA,EAAa;AACX,cAAIG,IAAAA,GAAOC,MAAAA,CAAAA,IAAAA,CAAYF,aAAAA,CAAvB,OAAWE,CAAX;;AACA,eAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,OAAAA,GAAUH,IAAAA,CAA1B,MAAA,EAAuCE,CAAAA,GAAvC,OAAA,EAAoDA,CAApD,EAAA,EAAyD;AACvD,gBAAIlB,GAAAA,GAAMgB,IAAAA,CAAV,CAAUA,CAAV;AAEAJ,YAAAA,gBAAAA,CAAAA,GAAAA,CAAAA,GAAwBG,aAAAA,CAAAA,OAAAA,CAAAA,GAAAA,EAAxBH,SAAAA;AACD;AANH,SAAA,MAOO;AACL,cAAII,IAAAA,GAAOC,MAAAA,CAAAA,IAAAA,CAAX,gBAAWA,CAAX;;AACA,eAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,OAAAA,GAAUH,IAAAA,CAA1B,MAAA,EAAuCE,CAAAA,GAAvC,OAAA,EAAoDA,CAApD,EAAA,EAAyD;AACvD,gBAAIlB,GAAAA,GAAMgB,IAAAA,CAAV,CAAUA,CAAV;;AAEA,gBAAI,OAAA,CAAOD,aAAAA,CAAAA,OAAAA,CAAP,GAAOA,CAAP,CAAA,KAAJ,QAAA,EAAoD;AAClD,qBAAOH,gBAAAA,CAAP,GAAOA,CAAP;AACD;AACF;AACF;AACF;;AAED,UAAIQ,SAAAA,GAAJ,EAAA;;AAEA,WAAK,IAAL,GAAA,IAAA,gBAAA,EAAkC;AAChCA,QAAAA,SAAAA,CAAAA,IAAAA,CAAeR,gBAAAA,CAAfQ,GAAeR,CAAfQ;AACD;;AAED,UAAIC,cAAAA,GAAiB,KAArB,qBAAqB,EAArB,CArCqE,CAuCrE;;;AACA,aAAO,SAAA,CAAA,IAAA,CAAe,UAAA,SAAA,EAAA,SAAA,EAAA;AAAA,eACpBA,cAAAA,CAAAA,MAAAA,EAAAA,SAAAA,EAAAA,MAAAA,CAAAA,GACAA,cAAAA,CAAAA,MAAAA,EAAAA,SAAAA,EAFoB,MAEpBA,CAFoB;AAAtB,OAAO,CAAP;AAID;;;0CAEiC;AAChC,UAAInB,QAAAA,GAAW,KAAf,SAAA;AACA,UAAIoB,eAAAA,GAAkB,KAAtB,gBAAA;AAEA,aAAO,SAAA,YAAA,CAAA,KAAA,EAAA,SAAA,EAA0E;AAC/E,YAAI,CAACA,eAAAA,CAAL,KAAKA,CAAL,EAA6B;AAC3B,cAAIC,qBAAAA,GAA+B,OAAOrB,QAAAA,CAAP,KAAOA,CAAP,KAAA,WAAA,GAC/BA,QAAAA,CAAAA,KAAAA,CAAAA,CAD+B,uBAAA,GAAnC,CAAA;AAIAoB,UAAAA,eAAAA,CAAAA,KAAAA,CAAAA,GAAyB,IAAIE,IAAAA,CAAAA,GAAAA,CAASJ,SAAAA,CAAAA,MAAAA,IAAoB,IAA1DE,qBAAsCF,CAATI,CAA7BF;AACD;;AAED,eAAOA,eAAAA,CAAP,KAAOA,CAAP;AATF,OAAA;AAWD;;;4CAEmC;AAClC,UAAIpB,QAAAA,GAAW,KAAf,SAAA;AACA,UAAIuB,YAAAA,GAAe,KAAnB,aAAA;;AACA,UAAIC,YAAAA,GAAe,KAAnB,mBAAmB,EAAnB;;AAEA,aAAO,SAAA,cAAA,CAAA,MAAA,EAAA,QAAA,EAAA,SAAA,EAAuG;AAC5G,YAAIC,KAAAA,GAAJ,CAAA;;AAEA,aAAK,IAAId,CAAAA,GAAJ,CAAA,EAAWC,SAAAA,GAAYJ,MAAAA,CAA5B,MAAA,EAA2CG,CAAAA,GAA3C,SAAA,EAA0D,EAA1D,CAAA,EAA+D;AAC7D,cAAId,KAAAA,GAAeW,MAAAA,CAAnB,CAAmBA,CAAnB;AAEA,cAAIkB,wBAAAA,GAAkCF,YAAAA,CAAAA,KAAAA,EAAtC,SAAsCA,CAAtC;;AAEA,cAAIE,wBAAAA,KAAJ,QAAA,EAA2C;AACzCA,YAAAA,wBAAAA,GAAAA,CAAAA;AACD;;AAED,cAAA,GAAA;;AACA,cAAIH,YAAAA,YAAJ,KAAA,EAAmC;AACjCzB,YAAAA,GAAAA,GAAM6B,QAAAA,IAAY,CAAA,GAAA,qBAAA,CAAA,OAAA,EAAA,QAAA,EAAlB7B,YAAkB,CAAlBA;AADF,WAAA,MAEO;AACLA,YAAAA,GAAAA,GAAM6B,QAAAA,IAAYA,QAAAA,CAAlB7B,YAAkB6B,CAAlB7B;AACD;;AAED,cAAI8B,aAAAA,GACF,OAAO5B,QAAAA,CAAP,KAAOA,CAAP,KAAA,WAAA,IACA,OAAOA,QAAAA,CAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAP,GAAOA,CAAP,KADA,WAAA,GAEIA,QAAAA,CAAAA,KAAAA,CAAAA,CAAAA,OAAAA,CAAAA,GAAAA,EAFJ,oBAAA,GADF,CAAA;AAMAyB,UAAAA,KAAAA,IAASG,aAAAA,GAATH,wBAAAA;AACD;;AAED,eAAA,KAAA;AA5BF,OAAA;AA8BD;;;;;;AACF","sourcesContent":["// @flow\nimport getNestedFieldValue from '../getNestedFieldValue';\n\nimport type { ISearchIndex } from './SearchIndex';\n\ntype ITfIdfTokenMap = {\n  [token : string] : ITfIdfTokenMetadata;\n};\n\ntype ITfIdfUidMap = {\n  [uid : string] : ITfIdfUidMetadata;\n};\n\ntype ITfIdfTokenMetadata = {\n  $numDocumentOccurrences : number;\n  $totalNumOccurrences : number;\n  $uidMap : ITfIdfUidMap;\n};\n\ntype ITfIdfUidMetadata = {\n  $document : Object;\n  $numTokenOccurrences : number;\n};\n\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\nexport class TfIdfSearchIndex implements ISearchIndex {\n  _uidFieldName : string | Array<string>;\n  _tokenToIdfCache : {[token : string] : number};\n  _tokenMap : ITfIdfTokenMap;\n\n  constructor(uidFieldName : string | Array<string>) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n\n  /**\n   * @inheritDocs\n   */\n  indexDocument(token : string, uid : string, doc : Object) : void {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {},\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n\n    var uidMap = tokenDatum.$uidMap;\n\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n\n  /**\n   * @inheritDocs\n   */\n  search(tokens : Array<string>, corpus : Array<Object>) : Array<Object> {\n    var uidToDocumentMap : {[uid : string] : Object} = {};\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token];\n\n      // Short circuit if no matches were found for any given token.\n      if (!tokenMetadata) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var documents = [];\n\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n\n    var calculateTfIdf = this._createCalculateTfIdf();\n\n    // Return documents sorted by TF-IDF\n    return documents.sort((documentA, documentB) =>\n      calculateTfIdf(tokens, documentB, corpus) -\n      calculateTfIdf(tokens, documentA, corpus)\n    );\n  }\n\n  _createCalculateIdf () : Function {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n\n    return function calculateIdf(token : string, documents : Array<Object>) : number {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken:number = typeof tokenMap[token] !== 'undefined'\n          ? tokenMap[token].$numDocumentOccurrences\n          : 0;\n\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n\n      return tokenToIdfCache[token];\n    }\n  }\n\n  _createCalculateTfIdf () : Function {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n    var calculateIdf = this._createCalculateIdf();\n\n    return function calculateTfIdf(tokens : Array<string>, document : Object, documents : Array<Object>) : number {\n      var score:number = 0;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token:string = tokens[i];\n\n        var inverseDocumentFrequency:number = calculateIdf(token, documents);\n\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n\n        var uid:any;\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n\n        var termFrequency:number =\n          typeof tokenMap[token] !== 'undefined' &&\n          typeof tokenMap[token].$uidMap[uid] !== 'undefined'\n            ? tokenMap[token].$uidMap[uid].$numTokenOccurrences\n            : 0;\n\n        score += termFrequency * inverseDocumentFrequency;\n      }\n\n      return score;\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}