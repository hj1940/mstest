{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenHighlighter = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _index = require('./IndexStrategy/index');\n\nvar _index2 = require('./Sanitizer/index');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\n\n\nvar TokenHighlighter = exports.TokenHighlighter = function () {\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    _classCallCheck(this, TokenHighlighter);\n\n    this._indexStrategy = opt_indexStrategy || new _index.PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new _index2.LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n\n  _createClass(TokenHighlighter, [{\n    key: 'highlight',\n    value: function highlight(text, tokens) {\n      var tagsLength = this._wrapText('').length;\n\n      var tokenDictionary = Object.create(null); // Create a token map for easier lookup below.\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = this._sanitizer.sanitize(tokens[i]);\n\n        var expandedTokens = this._indexStrategy.expandToken(token);\n\n        for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n          var expandedToken = expandedTokens[j];\n\n          if (!tokenDictionary[expandedToken]) {\n            tokenDictionary[expandedToken] = [token];\n          } else {\n            tokenDictionary[expandedToken].push(token);\n          }\n        }\n      } // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n\n\n      var actualCurrentWord = '';\n      var sanitizedCurrentWord = '';\n      var currentWordStartIndex = 0; // Note this assumes either prefix or full word matching.\n\n      for (var i = 0, textLength = text.length; i < textLength; i++) {\n        var character = text.charAt(i);\n\n        if (character === ' ') {\n          actualCurrentWord = '';\n          sanitizedCurrentWord = '';\n          currentWordStartIndex = i + 1;\n        } else {\n          actualCurrentWord += character;\n          sanitizedCurrentWord += this._sanitizer.sanitize(character);\n        }\n\n        if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n          actualCurrentWord = this._wrapText(actualCurrentWord);\n          text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n          i += tagsLength;\n          textLength += tagsLength;\n        }\n      }\n\n      return text;\n    }\n    /**\n     * @param text to wrap\n     * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n     * @private\n     */\n\n  }, {\n    key: '_wrapText',\n    value: function _wrapText(text) {\n      var tagName = this._wrapperTagName;\n      return '<' + tagName + '>' + text + '</' + tagName + '>';\n    }\n  }]);\n\n  return TokenHighlighter;\n}();\n\n;","map":{"version":3,"sources":["../../source/TokenHighlighter.js"],"names":["TokenHighlighter","opt_indexStrategy","opt_sanitizer","opt_wrapperTagName","text","tokens","tagsLength","tokenDictionary","Object","i","numTokens","token","expandedTokens","j","numExpandedTokens","expandedToken","actualCurrentWord","sanitizedCurrentWord","currentWordStartIndex","textLength","character","tagName"],"mappings":"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","sourcesContent":["// @flow\n\nimport { PrefixIndexStrategy } from './IndexStrategy/index';\nimport { LowerCaseSanitizer } from './Sanitizer/index';\n\nimport type { IIndexStrategy } from './IndexStrategy/index';\nimport type { ISanitizer } from './Sanitizer/index';\n\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\nexport class TokenHighlighter {\n  _indexStrategy : IIndexStrategy;\n  _sanitizer : ISanitizer\n  _wrapperTagName : string;\n\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  constructor(opt_indexStrategy : IIndexStrategy, opt_sanitizer : ISanitizer, opt_wrapperTagName:string) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n  highlight(text : string, tokens : Array<string>) {\n    var tagsLength : number = this._wrapText('').length;\n\n    var tokenDictionary = ((Object.create(null): any): Object);\n\n    // Create a token map for easier lookup below.\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token : string = this._sanitizer.sanitize(tokens[i]);\n      var expandedTokens : Array<string> = this._indexStrategy.expandToken(token);\n\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken : string = expandedTokens[j];\n\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    }\n\n    // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n    var actualCurrentWord : string = '';\n    var sanitizedCurrentWord : string = '';\n    var currentWordStartIndex : number = 0;\n\n    // Note this assumes either prefix or full word matching.\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character : string = text.charAt(i);\n\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n\n      if (tokenDictionary[sanitizedCurrentWord] &&\n        tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n\n    return text;\n  }\n\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */\n  _wrapText(text : string) : string {\n    const tagName = this._wrapperTagName;\n    return `<${tagName}>${text}</${tagName}>`;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}