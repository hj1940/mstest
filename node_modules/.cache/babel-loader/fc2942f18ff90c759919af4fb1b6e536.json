{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\n\n\nvar UnorderedSearchIndex = exports.UnorderedSearchIndex = function () {\n  function UnorderedSearchIndex() {\n    _classCallCheck(this, UnorderedSearchIndex);\n\n    this._tokenToUidToDocumentMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  _createClass(UnorderedSearchIndex, [{\n    key: 'indexDocument',\n    value: function indexDocument(token, uid, doc) {\n      if (_typeof(this._tokenToUidToDocumentMap[token]) !== 'object') {\n        this._tokenToUidToDocumentMap[token] = {};\n      }\n\n      this._tokenToUidToDocumentMap[token][uid] = doc;\n    }\n    /**\n     * @inheritDocs\n     */\n\n  }, {\n    key: 'search',\n    value: function search(tokens, corpus) {\n      var intersectingDocumentMap = {};\n      var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n        var token = tokens[i];\n        var documentMap = tokenToUidToDocumentMap[token]; // Short circuit if no matches were found for any given token.\n\n        if (!documentMap) {\n          return [];\n        }\n\n        if (i === 0) {\n          var keys = Object.keys(documentMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n            intersectingDocumentMap[uid] = documentMap[uid];\n          }\n        } else {\n          var keys = Object.keys(intersectingDocumentMap);\n\n          for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n            var uid = keys[j];\n\n            if (_typeof(documentMap[uid]) !== 'object') {\n              delete intersectingDocumentMap[uid];\n            }\n          }\n        }\n      }\n\n      var keys = Object.keys(intersectingDocumentMap);\n      var documents = [];\n\n      for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n        var uid = keys[i];\n        documents.push(intersectingDocumentMap[uid]);\n      }\n\n      return documents;\n    }\n  }]);\n\n  return UnorderedSearchIndex;\n}();\n\n;","map":{"version":3,"sources":["../../../source/SearchIndex/UnorderedSearchIndex.js"],"names":["UnorderedSearchIndex","token","uid","doc","tokens","corpus","intersectingDocumentMap","tokenToUidToDocumentMap","i","numTokens","documentMap","keys","Object","j","numKeys","documents"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;IAGaA,oB,WAAAA,oB;AAGX,WAAA,oBAAA,GAAc;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,oBAAA,CAAA;;AACZ,SAAA,wBAAA,GAAA,EAAA;AACD;AAED;;;;;;;kCAGcC,K,EAAgBC,G,EAAcC,G,EAAqB;AAC/D,UAAI,OAAA,CAAO,KAAA,wBAAA,CAAP,KAAO,CAAP,CAAA,KAAJ,QAAA,EAA8D;AAC5D,aAAA,wBAAA,CAAA,KAAA,IAAA,EAAA;AACD;;AAED,WAAA,wBAAA,CAAA,KAAA,EAAA,GAAA,IAAA,GAAA;AACD;AAED;;;;;;2BAGOC,M,EAAwBC,M,EAAwC;AACrE,UAAIC,uBAAAA,GAAJ,EAAA;AAEA,UAAIC,uBAAAA,GAA0B,KAA9B,wBAAA;;AAEA,WAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,SAAAA,GAAYL,MAAAA,CAA5B,MAAA,EAA2CI,CAAAA,GAA3C,SAAA,EAA0DA,CAA1D,EAAA,EAA+D;AAC7D,YAAIP,KAAAA,GAAQG,MAAAA,CAAZ,CAAYA,CAAZ;AACA,YAAIM,WAAAA,GAAcH,uBAAAA,CAAlB,KAAkBA,CAAlB,CAF6D,CAI7D;;AACA,YAAI,CAAJ,WAAA,EAAkB;AAChB,iBAAA,EAAA;AACD;;AAED,YAAIC,CAAAA,KAAJ,CAAA,EAAa;AACX,cAAIG,IAAAA,GAAOC,MAAAA,CAAAA,IAAAA,CAAX,WAAWA,CAAX;;AAEA,eAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,OAAAA,GAAUH,IAAAA,CAA1B,MAAA,EAAuCE,CAAAA,GAAvC,OAAA,EAAoDA,CAApD,EAAA,EAAyD;AACvD,gBAAIX,GAAAA,GAAMS,IAAAA,CAAV,CAAUA,CAAV;AAEAL,YAAAA,uBAAAA,CAAAA,GAAAA,CAAAA,GAA+BI,WAAAA,CAA/BJ,GAA+BI,CAA/BJ;AACD;AAPH,SAAA,MAQO;AACL,cAAIK,IAAAA,GAAOC,MAAAA,CAAAA,IAAAA,CAAX,uBAAWA,CAAX;;AAEA,eAAK,IAAIC,CAAAA,GAAJ,CAAA,EAAWC,OAAAA,GAAUH,IAAAA,CAA1B,MAAA,EAAuCE,CAAAA,GAAvC,OAAA,EAAoDA,CAApD,EAAA,EAAyD;AACvD,gBAAIX,GAAAA,GAAMS,IAAAA,CAAV,CAAUA,CAAV;;AAEA,gBAAI,OAAA,CAAOD,WAAAA,CAAP,GAAOA,CAAP,CAAA,KAAJ,QAAA,EAA0C;AACxC,qBAAOJ,uBAAAA,CAAP,GAAOA,CAAP;AACD;AACF;AACF;AACF;;AAED,UAAIK,IAAAA,GAAOC,MAAAA,CAAAA,IAAAA,CAAX,uBAAWA,CAAX;AACA,UAAIG,SAAAA,GAAJ,EAAA;;AAEA,WAAK,IAAIP,CAAAA,GAAJ,CAAA,EAAWM,OAAAA,GAAUH,IAAAA,CAA1B,MAAA,EAAuCH,CAAAA,GAAvC,OAAA,EAAoDA,CAApD,EAAA,EAAyD;AACvD,YAAIN,GAAAA,GAAMS,IAAAA,CAAV,CAAUA,CAAV;AAEAI,QAAAA,SAAAA,CAAAA,IAAAA,CAAeT,uBAAAA,CAAfS,GAAeT,CAAfS;AACD;;AAED,aAAA,SAAA;AACD;;;;;;AACF","sourcesContent":["// @flow\n\nimport type { ISearchIndex } from './SearchIndex';\n\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\nexport class UnorderedSearchIndex implements ISearchIndex {\n  _tokenToUidToDocumentMap : {[token : string] : {[uid : string] : any}};\n\n  constructor() {\n    this._tokenToUidToDocumentMap = {};\n  }\n\n  /**\n   * @inheritDocs\n   */\n  indexDocument(token : string, uid : string, doc : Object) : void {\n    if (typeof this._tokenToUidToDocumentMap[token] !== 'object') {\n      this._tokenToUidToDocumentMap[token] = {};\n    }\n\n    this._tokenToUidToDocumentMap[token][uid] = doc;\n  }\n\n  /**\n   * @inheritDocs\n   */\n  search(tokens : Array<string>, corpus : Array<Object>) : Array<Object> {\n    var intersectingDocumentMap = {};\n\n    var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var documentMap = tokenToUidToDocumentMap[token];\n\n      // Short circuit if no matches were found for any given token.\n      if (!documentMap) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(documentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          intersectingDocumentMap[uid] = documentMap[uid];\n        }\n      } else {\n        var keys = Object.keys(intersectingDocumentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof documentMap[uid] !== 'object') {\n            delete intersectingDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var keys = Object.keys(intersectingDocumentMap);\n    var documents = [];\n\n    for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n      var uid = keys[i];\n\n      documents.push(intersectingDocumentMap[uid]);\n    }\n\n    return documents;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}